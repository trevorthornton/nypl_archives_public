module EadExport

  class EadRecord
    
    require 'nokogiri'
    include ApplicationHelper
    include OrgUnitsHelper
  
    def initialize(options = {})
      if !options[:collection_id]
        raise ArgumentError, ":collection_id is required in the arguments hash - cannot generate EAD record"
      else
        @collection = Collection.includes(:description, :org_unit, :access_term_associations).find options[:collection_id]
        if @collection
          @data = JSON.parse(@collection.response.desc_data)
          # Add alternate template for EAD3 when released
          # options[:schema] ||= '2002'
          source = "lib/xml_templates/ead2002_template.xml"
          @doc = Nokogiri::XML(open(source))
          @ead = @doc.root()
        end
      end
    end
    
    
    def generate
      generate_eadheader_content()
      generate_archdesc_content()
      reverse_html_conversion()
      add_namespaces_to_ead()
      @doc.to_s
    end
    
    
    def add_namespaces_to_ead
      @ead['xmlns'] = "urn:isbn:1-931666-22-9"
      @ead['xmlns:xsi'] = "http://www.w3.org/2001/XMLSchema-instance"
      @ead['xsi:schemaLocation'] = "urn:isbn:1-931666-22-9 http://www.loc.gov/ead/ead.xsd"
    end
    
    
    def generate_eadheader_content
      @eadheader = @ead.xpath('./eadheader').first()
            
      # add eadid
      @eadid = Nokogiri::XML::Node.new('eadid', @doc)
      @eadid['countrycode'] = 'US'
      @eadid['mainagencycode'] = 'US-NN'
      collection_path = persistent_collection_path(:identifier_value => @collection.identifier_value,
        :org_unit_code => @collection.org_unit.code, :id => @collection.id)
      @eadid['url'] = "http://archives.nypl.org#{collection_path}.xml"
      
      @eadid << @collection.persistent_path.gsub(/\//,'') + '.xml'
      @eadheader << @eadid
      
      # add filedesc
      @filedesc = Nokogiri::XML::Node.new('filedesc', @doc)
      @titlestmt = Nokogiri::XML::Node.new('titlestmt', @doc)
      @titleproper = Nokogiri::XML::Node.new('titleproper', @doc)
      # @titleproper['encodinganalog'] = '245$a'
      @titleproper << "Guide to the #{@collection.title}"
            
      @titlestmt << @titleproper
            
      if @data['processinfo']
        @data['processinfo'].each_index do |i|
          if @data['processinfo'][i]['value'].match('Compiled by')
            author_text = @data['processinfo'][i]['value'].gsub(/\<\/?p\>/,'')
            @data['processinfo'].delete_at(i)
            @author = Nokogiri::XML::Node.new('author', @doc)
            # @author['encodinganalog'] = '245$c'
            @author << author_text
            @titlestmt << @author
            break
          end
        end
      end
      
      if @data['sponsor']
        @data['sponsor'].each do |s|
          if s['value'] && !s['value'].empty?
            @sponsor = Nokogiri::XML::Node.new('sponsor', @doc)
            @sponsor << s['value']
            @titlestmt << @sponsor
          end
        end
      end
      
      @filedesc << @titlestmt
      
      # add publicationstmt
      @publicationstmt = Nokogiri::XML::Node.new('publicationstmt', @doc)
      @publicationstmt << "<publisher>The New York Public Library. #{@collection.org_unit.name}.</publisher>"
      @publicationstmt << repository_address()
      @filedesc << @publicationstmt
      
      @eadheader << @filedesc
      
      # add profiledesc
      @profiledesc = Nokogiri::XML::Node.new('profiledesc', @doc)
      creation = '<creation>EAD generated by archives.nypl.org on <date normal="'
      creation += DateTime.now.strftime('%F') + '">'
      creation += "#{DateTime.now.strftime('%B %e, %Y')}</date></creation>"
      @profiledesc << creation
      @profiledesc << '<langusage><language langcode="eng">English</language></langusage>'
      
      @eadheader << @profiledesc
    end
    
    
    def generate_archdesc_content
      @archdesc = @ead.xpath('./archdesc').first()
      @archdesc << generate_did(@data,'Collection')
      add_non_did_elements(@archdesc, @data)
      add_controlaccess(@archdesc, @data)
      if !@collection.components.empty?
        add_dsc_to_archdesc()
      end
    end
    

    def add_dsc_to_archdesc
      @dsc = Nokogiri::XML::Node.new('dsc', @doc)
      
      component_name = lambda do |level|
        level_txt = level.to_s.length == 1 ? ('0' + level.to_s) : level.to_s
        return "c" + level_txt
      end
      
      generate_component = lambda do |component_data|
        c = Nokogiri::XML::Node.new(component_name.call(component_data['level_num']), @doc)
        if component_data['level_text']
          c['level'] = component_data['level_text']
        end
        c << generate_did(component_data,'Component')
        add_non_did_elements(c,component_data)
        add_controlaccess(c, component_data)
        return c
      end
      
      process_sub_components = Proc.new do |children, element|
        if !children.empty?
          children.each do |child|
            child_response = ComponentResponse.where(:component_id => child['id']).first
            child_data = JSON.parse(child_response.desc_data)
            child_structure = JSON.parse(child_response.structure)            
            c = generate_component.call(child_data)            
            if !child_structure['children'].empty?
              process_sub_components.call(child_structure['children'],c)
            end
            element << c
          end
        end
      end
      
      process_components = Proc.new do
        if !@collection.children.empty?
          @collection.children.each do |child|
            child_data = JSON.parse(child.response.desc_data)
            child_structure = JSON.parse(child.response.structure)            
            c = generate_component.call(child_data)         
            if !child_structure['children'].empty?
              process_sub_components.call(child_structure['children'],c)
            end
            @dsc << c
          end
        end
      end
      
      process_components.call
      
      if !@dsc.blank?
        @archdesc << @dsc
      end
    end
    
    
    # record is either a collection or component object
    # description is the parsed (json to ruby) content of self.description.data 
    def generate_did(data, record_type)
      # data ||= JSON.parse(record.description.data)
      did = Nokogiri::XML::Node.new('did', @doc)
      
      # unittitle - take title from record attributes
      if data['title']
        unittitle = Nokogiri::XML::Node.new('unittitle', @doc)
        unittitle << data['title']
        did << unittitle
      end
      
      # unitdate
      if data['unitdate']
        data['unitdate'].each do |element_data|
          if element_data['value']
            did << generate_standard_element('unitdate', element_data)
          end
        end
      end
      
      # unitid & physloc
      if data['unitid']
        data['unitid'].each do |element_data|
          if element_data['value']
            did << generate_standard_element('unitid', element_data)
          end
        end
      end
      
      # origination
      originations = []
      if data['origination_term']
        data['origination_term'].each do |ot|
          originations << ot
        end
      elsif data['origination']
        case data['origination']
        when Array
          data['origination'].each do |o|
            case o
            when String
              originations << { 'term' => o }
            when Hash
              o['term'] ||= o['value']
              originations << o
            end
          end
        when String
          originations << { 'term' => data['origination'] }
        end
      end
      originations.each do |o|
        if o['term']
          origination = Nokogiri::XML::Node.new('origination', @doc)
          if o['type']
            name_element = Nokogiri::XML::Node.new(o['type'], @doc)
            name_element << o['term']
            name_element['role'] = o['role'] if o['role']
            name_element['source'] = o['source'] if o['source']
            origination << name_element
          else
            origination << o['term']
          end
          did << origination
        end
      end
      # END - origination

      if record_type == 'Collection'
        # repository
        repository = '<repository>'
        repository += "<corpname>The New York Public Library. #{@collection.org_unit.name}.</corpname>"
        repository += repository_address()
        repository += '</repository>'
        did << repository
      end
      
      # physdesc
      if data['physdesc']
        data['physdesc'].each do |p|
          physdesc = Nokogiri::XML::Node.new('physdesc', @doc)
          add_attributes_to_element(physdesc, p)
          case p['format']
          when 'structured'
            elements = p['physdesc_components']
            if elements
              elements.each do |e|
                if e['value']
                  physdesc << generate_standard_element(e['name'], e)
                end
              end
            end
          when 'simple', nil
            physdesc << p['value'] if p['value']
          end
          did << physdesc
        end
      end
      
      # materialspec, abstract, odd, langmaterial
      ['container','materialspec', 'abstract', 'odd', 'langmaterial', 'physloc'].each do |name|
        if data[name]
          data[name].each do |element_data|
            if element_data['value']
              did << generate_standard_element(name, element_data)
            end
          end
        end
      end

      did
    end
    
    
    def add_non_did_elements(parent_element, data)
      non_did_elements = ['bioghist', 'custodhist', 'scopecontent', 'prefercite', 'arrangement', 'accruals', 'acqinfo',
        'separatedmaterial', 'processinfo', 'appraisal', 'relatedmaterial',
        'bibliography', 'accessrestrict', 'userestrict',
        'legalstatus', 'phystech', 'altformavail', 'originalsloc', 'otherfindaid']
      non_did_elements.each do |n|
        if data[n]
          data[n].each do |e|
            # add standard access note to accessrestrict
            if n == 'accessrestrict' && data['standard_access_note']
              e ||= {}
              e['value'] = "<p>#{data['standard_access_note']}</p>" + e['value']
            end
            if n == 'scopecontent' && e['type'] == "arrangement"
              # skip
            else
              if e['value']
                parent_element << generate_standard_element(n, e, :structured => true)
              end
            end
          end
        end
      end
    end
    
    
    def add_controlaccess(parent_element, data)
      if data['controlaccess']
        controlaccess = Nokogiri::XML::Node.new('controlaccess',@doc)
        element_types = ['name', 'subject', 'title', 'genreform', 'geogname', 'occupation']
        element_types.each do |e|
          if data['controlaccess'][e]
            data['controlaccess'][e].each do |t|
              if t['function'] == 'occupation'
                element_name = 'occupation'
              else
                element_name = t['type'] == 'topic' ? 'subject' : t['type']
              end
              term_element = Nokogiri::XML::Node.new(element_name,@doc)
              term_element << t['term']
              term_element['role'] = t['role'] if t['role']
              term_element['source'] = t['source'] if t['source']
              controlaccess << term_element
            end
          end
        end
        parent_element << controlaccess
      end
    end
    
    
    def generate_standard_element(element_name, element_data, options={})
      element = Nokogiri::XML::Node.new(element_name, @doc)
      element_data.each do |k,v|
        if k == 'value'
          # fix prefercite - stored value not wrapped in '<p>'
          if options[:structured]
            value = !v.match(/^\<(.+)\>$/) ? "<p>#{v}</p>" : v
            element << value
          else
            element << v
          end          
        else
          if !add_attributes_to_element(element, element_data) 
            element[k] = v
          end
        end
      end
      element
    end
    
    
    def allowed_attributes(element_name)
      attributes = {
        'unitid' => ['altrender','audience','encodinganalog','id','label','type'],
        'origination' => ['altrender','audience','encodinganalog','id','label'],
        'bioghist' => ['altrender','audience','encodinganalog','id'],
        'abstract' => ['altrender','audience','encodinganalog','id','label','langcode','type'],
        'odd' => ['altrender','audience','encodinganalog','id','type'],
        'prefercite' => ['altrender','audience','encodinganalog','id'],
        'materialspec' => ['altrender','audience','encodinganalog','id','label','type'],
        'langmaterial' => ['altrender','audience','encodinganalog','id','label'],
        'container' => ['altrender','audience','encodinganalog','id','label','type'],
        'physdesc' => ['altrender','audience','encodinganalog','id','label','rules','source'],
        'dimension' => ['altrender','audience','encodinganalog','id','label','type','unit'],
        'extent' => ['altrender','audience','encodinganalog','id','label','type','unit'],
        'genreform' => ['altrender','audience','authfilenumber','encodinganalog','id','normal','rules','source','type'],
        'physfacet' => ['altrender','audience','encodinganalog','id','label','rules','source','type','unit']
      }
      default = ['altrender','audience','encodinganalog','id']
      return attributes[element_name] ? attributes[element_name] : default
    end
    
    
    # any element passed to this must have it's allowed attributes specified in allowed_attributes()
    def add_attributes_to_element(element, data)
      begin
        allowed_attributes(element.name).each do |a|
          element[a] = data[a] if data[a]
        end
        true
      rescue Exception => e
        puts e
        puts "Make sure attributes for #{element.name} are included in allowed_attributes()."
        nil
      end
    end
    
        
    def repository_address
      center_data = centers[@collection.org_unit.center]
      address = "<address>"
      address += "<addressline>#{center_data[:name]}</addressline>"
      address += "<addressline>#{center_data[:address]}</addressline>"
      address += "</address>"
    end
    
    
    def reverse_html_conversion
      block_elements = ['note','address','bioghist','scopecontent','arrangement']
      inline_elements = ['abbr','addressline','archref','bibref','bibseries','date',
        'edition', 'emph','expan','imprint','num','subarea','persname','famname','corpname',
        'genreform','geogname','name','subject','title','occupation']
      list_elements = ['chronlist','list']
      list_content_elements = ['chronitem','eventgrp','date','event','item','defitem']
      head_elements = ['head','head01','head02']
      table_elements = ['table','tgroup','colspec','tbody','thead','row']
      
      replace_element = Proc.new do |xpath, name|
        @ead.xpath(xpath).each do |e|
          e.remove_attribute('class')
          e.name = name
        end
      end
      
      block_elements.each do |b|
        xpath = '//div[@class="' + b + '"]'
        replace_element.call(xpath,b)
      end
      
      inline_elements.each do |i|
        xpath = '//span[@class="' + i + '"]'
        replace_element.call(xpath,i)
      end
      
      # lists
      @ead.xpath('//ol').each do |e|
        e.name = 'list'
        e['type'] = 'ordered'
      end
      @ead.xpath('//ul').each do |e|
        e.name = 'list'
        e['type'] = 'simple'
      end
      @ead.xpath('//li').each do |e|
        e.name = 'item'
      end
      
      # head
      head_xpath = '//div[@class="head"]|//div[@class="head01"]|//div[@class="head02"]'
      replace_element.call(head_xpath,'head')
    end
  end
  
  
end